#include <stdio.h>
#include <stdlib.h>
#define TRUE 1
#define FALSE 0

/*
p.414에 있는 Tic-Tac-Toe 게임을 수행할 수 있는 프로그램을 작성하시오.
예제에 있는 내용에서 다음의 내용이 추가되어야 합니다.

1. 게임이 종료(한명이라도 승리 했는지)하는 조건을 검사하는 함수 추가
2. 예제는 3 * 3게임만 할 수 있지만, 사용자가 원하면 5 * 5, 7 * 7 등의 게임을 추가(최대 99?)
3. 사람과 사람이 대결하는 것이 아니라 사람과 컴퓨터가 대결할 수 있도록 추가
(랜덤으로 놓기, 비어있는 위치 중 가장 앞 위치 놓기, 가장 유리한 곳 놓기 등) 
*/

int length;

void print_board (char board[100][100] )
{
   int j,k;

   for( j = 0 ; j < length ; j++)  
   {
      for( k = 0 ; k < length ; k++)
         printf("|%c",board[j][k]);
      
   		printf("|\n");
	}
	
   return;   
}

void init_board (char board[100][100])
{
   int x,y;
   
   for( x=0 ; x<100 ; x++)
      for( y=0 ; y<100 ; y++)
         board[x][y] =' ';
      
   return;
}

int get_player_move(int player, char board[100][100]) 
{    
	int x, y; 
	   // done = 1 ??
	while(1) 
	{        
		printf("(x, y) 좌표(종료-1, -1): ");        
		scanf("%d %d", &x, &y); 
		       
		if( x == -1 && y == -1 ) 
			return  TRUE;
			        
		if(board[x][y]== ' ') 
			break;  // 올바른 위치이면 반복 루프를 나간다.        
		else 
			printf("잘못된 위치입니다.\n");    
	}    
	
	if( player == 0 ) 
		board[x][y] = 'X';    
	else 
		board[x][y] = 'O';
    
	return FALSE; 
}


int check_board_H(char current_user, char board[100][100]) 
{    
	int i1,m;
	char winner='U';
	
    for(i1=0; i1<length; i1++)
	{   
		for(m=0 ; m<length ; m++)		
			if( board[i1][m] != current_user)  
				break;
	
		if( m == length )
			{
				printf("winner = %c",current_user);         
				
				return TRUE;
			} 
	}
	
	if( i1 == length)
		return FALSE;
}


int check_board_V (char current_user,char board[100][100] ) 
{

	int i2,m;
	char winner='U';
	
	for(i2=0; i2<length; i2++)
	{   
		for(m=0 ; m<length ; m++)   
			if( board[m][i2] != current_user)	
				break;
		
		
		if( m == length )
		{
			printf("winner = %c",current_user);         
					
			return TRUE;
		}
					
	}
	
	if( i2 == length)
		return FALSE;
		
}

int check_board_CL(char current_user, char board[100][100])	
{
	int len,i3,m;
	char winner='U';
	
	for(i3=0; i3<length; i3++)
		if( board[i3][i3] != current_user  )
			break;
			
	if( i3 == length )
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}

int check_board_CR(char current_user, char board[100][100])	
{
	int i4;

	for(i4=0; i4<length; i4++)
		if( board[i4][length- i4 - 1] != current_user )
			break;

	
	if( i4 == length )
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}  

int get_next_move(char board[100][100])
{
	int x, y;
		
	for(x=0; x<length; x++) 
		for(y=0; y<length; y++) 
		{
			if( board[x][y] == ' ')
			{ 
				board[x][y] = 'O';
				printf(" 컴퓨터 (%d,%d)\n",x,y);	
					
				return FALSE;
			}
		}
}


int main(int argc, char *argv[]) 
{ 
    char board[100][100];
    int quit;
    int type;
    
    init_board (board);
    
	printf("사람과 사람 대결(2인용) : 1을 입력하세요\n");
   	printf("컴퓨터와 게임(1인용) : 2를 입력하세요\n:");
   	scanf("%d", &type);
    
    printf("\n\n첫번째 사람은 X, 두번째 사람은 O입니다.\n\n");
    
    printf("상자의 크기를 입력하세요 :");
    scanf("%d",&length);

	print_board (board);  
	 
	switch(type)
	{
		
		case 1:		
		 	do {  
		      
			   
			   quit = get_player_move(0, board);        
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  )
			   		break;        
			   
			   quit = get_player_move(1,board);        
			   
			   if( quit == TRUE ) break;  
			   
			   print_board (board);     
			   
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) 
			   		break;
			   		
			
			} while(quit == FALSE ); 
		   
		   break;
		
		case 2:
			do {  
		      
			   
			   quit = get_player_move(0, board);        
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  )
			   		break;        
			   
			   quit = get_next_move(board);        
			   
			   if( quit == TRUE ) break;  
			   
			   print_board (board);     
			   
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) 
			   		break;
			   		
			
			} while(quit == FALSE ); 
		   
		   break;
			
	 	default:
		 	printf(" 잘못입력하였습니다. 다시 시작하세요. ");
			break;  
	}
	
	return 0;
}




#include <stdio.h>
#include <stdlib.h>
#define TRUE 1	// TRUE면 나갑니다. 
#define FALSE 0 // FALSE면 계속됩니다. 

/*
p.414에 있는 Tic-Tac-Toe 게임을 수행할 수 있는 프로그램을 작성하시오.
예제에 있는 내용에서 다음의 내용이 추가되어야 합니다.

1. 게임이 종료(한명이라도 승리 했는지)하는 조건을 검사하는 함수 추가
2. 예제는 3 * 3게임만 할 수 있지만, 사용자가 원하면 5 * 5, 7 * 7 등의 게임을 추가(최대 99?)
3. 사람과 사람이 대결하는 것이 아니라 사람과 컴퓨터가 대결할 수 있도록 추가
(랜덤으로 놓기, 비어있는 위치 중 가장 앞 위치 놓기, 가장 유리한 곳 놓기 등) 
*/

int length; // n*n 에서 n의 값입니다. 

void print_board (char board[100][100] ) // 입력받은 크기로 tic tac toe 판을 출력합니다. 
{
   int row,colum;   // 순서대로 게임 판의 가로,세로 입니다.  

   for( row = 0 ; row < length ; row++)  
   {
      for( colum  = 0 ; colum  < length ; colum ++)
         printf("|%c",board[row][colum ]);
      
   		printf("|\n");
	}
	
   return;   
}

void init_board (char board[100][100])	//배열을 공백으로 초기화합니다. 
{
   int x,y;
   
   for( x=0 ; x<100 ; x++)
      for( y=0 ; y<100 ; y++)
         board[x][y] =' ';
      
   return;
}

int get_player_move(int player, char board[100][100])  // 놓고 싶은 위치에 자신의 돌을 두게 합니다. 
{    
	int x, y; 
	  
	while(1) 			// 입력받은 위치가 비어있는 위치를 확인합니다  . 
	{        
		printf("(x, y) 좌표(종료-1, -1): ");        
		scanf("%d %d", &x, &y); 
		       
		if( x == -1 && y == -1 ) 
			return  TRUE;
			        
		     
		if( (x>= 0 && x<length) && (y>=0 && y<length) )
		{
		
			if(board[x][y]== ' ') 
				break;  // 올바른 위치이면 반복 루프를 나갑니다.   
			else 
				printf("잘못된 위치입니다.\n");    
		}
		else
			printf("잘못된 위치입니다.\n");   
	
	}
	    
	
	if( player == 0 ) 
		board[x][y] = 'X';    
	else 
		board[x][y] = 'O';
    
	return FALSE; 
}

// check_board ~ 는 게임에서 승리한 사람이 있는지 확인 해주는 함수 입니다.
 
int check_board_H(char current_user, char board[100][100])  // 배열의 각 행을 검사해  current_user가  한줄을 채웠는지 확인해 줍니다. 
{    
	int i1,m;
	char winner='U';
	
    for(i1=0; i1<length; i1++)	
	{   								 
		for(m=0 ; m<length ; m++)		
			if( board[i1][m] != current_user)	// 한 행을 검사하다가  현재 순서가 아닌 사람의 돌( O 또는 X )이 나오면 그 행을 더이상 확인하지 않고 나갑니다.   
				break;
	
		if( m == length )			// 위의 for문을 나갔을때  열(m)이  length 와 같다면 한 행이 모두 current_user의 돌이으므로  승자를 출력합니다. 
			{
				printf("winner = %c",current_user);         
				
				return TRUE;  
			} 
	}
	
	if( i1 == length)		// 모든 행을 검사했을때 if 문이 실행 됩니다. 이 경우는 한 행을 채운것이 없는 것이므로 FALSE를 반환합니다. 
		return FALSE;		 
}


int check_board_V (char current_user,char board[100][100] ) // 배열의 각 열을 검사해  current_user가  한 줄을 채웠는지 확인해 줍니다.
{

	int i2,m;
	char winner='U';
	
	for(i2=0; i2<length; i2++)
	{   
		for(m=0 ; m<length ; m++)   	// 한 열을 검사하다가  현재 순서가 아닌 사람의 돌( O 또는 X )이 나오면 그 열을 더이상 확인하지 않고 나갑니다.   
			if( board[m][i2] != current_user)	
				break;
		
		
		if( m == length )		// 위의 for문을 나갔을때  행(m)이  length 와 같다면 한 열이 모두 current_user의 돌이으므로  승자를 출력합니다. 
		{
			printf("winner = %c",current_user);         
					
			return TRUE;
		}
					
	}
	
	if( i2 == length)	// 모든 열을 검사했을때 if 문이 실행 됩니다. 이 경우는 한 열을 채운것이 없는 것이므로 FALSE를 반환합니다. 
		return FALSE;
		
}

int check_board_CL(char current_user, char board[100][100])	// 판의 왼쪽에서 시작하는 대각선이 채워졌는지 확인 합니다. 
{
	int i3,m;
	char winner='U';
	
	for(i3=0; i3<length; i3++)
		if( board[i3][i3] != current_user  )	// 대각선을 검사하다가 현재순서가 아닌 사람의 돌이 나오면 더 이상 확인 하지 않고 for문을 나갑니다. 
			break;
			
	if( i3 == length )		// for문을 나왔을때 대각선 끝까지 확인을 한 경우 이면( 대각선칸 모두가 O또는 X이면) 승자를 출력합니다. 
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}

int check_board_CR(char current_user, char board[100][100])	// 판의 오른쪽에서 시작하는 대각선이 채워졌는지 확인 합니다. 
{
	int i4;

	for(i4=0; i4<length; i4++)		
		if( board[i4][length- i4 - 1] != current_user )			// 대각선을 검사하다가 현재순서가 아닌 사람의 돌이 나오면 더 이상 확인 하지 않고 for문을 나갑니다. 
			break;

	
	if( i4 == length )				// for문을 나왔을때 대각선 끝까지 확인을 한 경우 이면( 대각선칸 모두가 O또는 X이면) 승자를 출력합니다. 
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}  

int get_next_move(char board[100][100])		// 컴퓨터와 하는 게임을 서선택 했을떄,  비어있는 칸을 확인해서 자동으로  돌을 놓는 함수 입니다. 
{
	int x, y;
		
	for(x=0; x<length; x++) 
		for(y=0; y<length; y++) 
		{
			if( board[x][y] == ' ') // 비어있는경우. 
			{ 
				board[x][y] = 'O';
				printf(" 컴퓨터 (%d,%d)\n",x,y);	
					
				return FALSE;
			}
		}
}


int main(int argc, char *argv[]) 
{ 
    char board[100][100]; 
    int quit;	// 종료할지를 받는 변수 
    int type; // 대결 종류를 받는 변수 
    
    init_board (board); // 배열안 모든 변수를 촉화 합니다. 
    
	printf("사람과 사람 대결 : 1을 입력하세요\n");
   	printf("컴퓨터와 대결 : 2를 입력하세요\n:");
   	scanf("%d", &type);
    
    printf("\n\n첫번째 사람은 X, 두번째 사람은 O입니다.\n\n");
    
    printf("상자의 크기를 입력하세요 :");
    scanf("%d",&length);

	print_board (board);  
	 
	switch(type)
	{
		
		case 1:		
		 	do {  
		      
			   
			   quit = get_player_move(0, board);        
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  ) //'X'돌을 가진 사람이 한줄을 채웠는지 확인합니다. 
			   		break;        		// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   
			   quit = get_player_move(1,board);        
			   
			   if( quit == TRUE ) break;  
			   
			   print_board (board);     
			   
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) //'O'돌을 가진 사람이 한줄을 채웠는지 확인합니다.
			   		break;				// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   		
			
			} while(quit == FALSE );  //quit가 TRUE면 나가게 됩니다. 
		   
		   break;
		
		case 2:
			do {  
		      
			   
			   quit = get_player_move(0, board);        
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  )
			   		break;        
			   
			   quit = get_next_move(board);        
			   
			   if( quit == TRUE ) break;  
			   
			   print_board (board);     
			   
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) 
			   		break;
			   		
			
			} while(quit == FALSE ); 
		   
		   break;
			
	 	default:
		 	printf(" 잘못입력하였습니다. 다시 시작하세요. ");
			break;  
	}
	
	return 0;
}





거의다...


#include <stdio.h>
#include <stdlib.h>
#define TRUE 1	// TRUE면 나갑니다. 
#define FALSE 0 // FALSE면 계속됩니다. 

/*
p.414에 있는 Tic-Tac-Toe 게임을 수행할 수 있는 프로그램을 작성하시오.
예제에 있는 내용에서 다음의 내용이 추가되어야 합니다.

1. 게임이 종료(한명이라도 승리 했는지)하는 조건을 검사하는 함수 추가
2. 예제는 3 * 3게임만 할 수 있지만, 사용자가 원하면 5 * 5, 7 * 7 등의 게임을 추가(최대 99?)
3. 사람과 사람이 대결하는 것이 아니라 사람과 컴퓨터가 대결할 수 있도록 추가
(랜덤으로 놓기, 비어있는 위치 중 가장 앞 위치 놓기, 가장 유리한 곳 놓기 등) 
*/

int length; // n*n 에서 n의 값입니다. 

void print_board (char board[100][100] ) // 입력받은 크기로 tic tac toe 판을 출력합니다. 
{
   int row,colum;   // 순서대로 게임 판의 가로,세로 입니다.  

   for( row = 0 ; row < length ; row++)  
   {
      for( colum  = 0 ; colum  < length ; colum ++)
         printf("|%c",board[row][colum ]);
      
   		printf("|\n");
	}
	
   return;   
}

void init_board (char board[100][100])	//배열을 공백으로 초기화합니다. 
{
   int x,y;
   
   for( x=0 ; x<100 ; x++)
      for( y=0 ; y<100 ; y++)
         board[x][y] =' ';
      
   return;
}

int get_player_move(int player, char board[100][100])  // 놓고 싶은 위치에 자신의 돌을 두게 합니다. 
{    
	int x, y; 
	  
	while(1) 			// 입력받은 위치가 비어있는 위치를 확인합니다  . 
	{        
		printf("(x, y) 좌표(종료-1, -1): ");        
		scanf("%d %d", &x, &y); 
		       
		if( x == -1 && y == -1 ) 
			return  TRUE;
			        
		     
		if( (x>= 0 && x<length) && (y>=0 && y<length) ) //입력받은 크기(length)보다 큰수를 받지 않도록 합니다. 
		{
		
			if(board[x][y]== ' ') 
				break;  // 올바른 위치이면 반복 루프를 나갑니다.   
			else 
				printf("잘못된 위치입니다.\n");    
		}
		else
			printf("잘못된 위치입니다.\n");   
	
	}
	    
	
	if( player == 0 ) 
		board[x][y] = 'X';    
	else 
		board[x][y] = 'O';
    
	return FALSE; 
}

int get_next_move(char board[100][100])		// 컴퓨터와 하는 게임을 선택 했을떄,  비어있는 칸을 확인해서 무작위로  돌을 놓는 함수 입니다. 
{
	int x, y;
	
	
	while(1)// 비어있는경우, 돌을 놓습니다.  아니라면 다시 다른 위치의 돌ㄹ을 받도록 합니다. 
	{
	
		x = rand()%length;
		y = rand()%length;
			
		 
		if( board[x][y] == ' ') // 비어이이는 경우. 
		{ 
			board[x][y] = 'O';
			printf(" 컴퓨터 (%d,%d)\n",x,y);
				
			return FALSE;	// 종료하는 경우가 없어 항상 FALS 를 반환합니다. 
		}
	}
					
}


// check_board ~ 는 게임에서 승리한 사람이 있는지 확인 해주는 함수 입니다.
 
int check_board_H(char current_user, char board[100][100])  // 배열의 각 행을 검사해  current_user가  한줄을 채웠는지 확인해 줍니다. 
{    
	int i1,m;
	char winner='U';
	
    for(i1=0; i1<length; i1++)	
	{   								 
		for(m=0 ; m<length ; m++)		
			if( board[i1][m] != current_user)	// 한 행을 검사하다가  현재 순서가 아닌 사람의 돌( O 또는 X )이 나오면 그 행을 더이상 확인하지 않고 나갑니다.   
				break;
	
		if( m == length )			// 위의 for문을 나갔을때  열(m)이  length 와 같다면 한 행이 모두 current_user의 돌이으므로  승자를 출력합니다. 
			{
				printf("winner = %c",current_user);         
				
				return TRUE;  
			} 
	}
	
	if( i1 == length)		// 모든 행을 검사했을때 if 문이 실행 됩니다. 이 경우는 한 행을 채운것이 없는 것이므로 FALSE를 반환합니다. 
		return FALSE;		 
}


int check_board_V (char current_user,char board[100][100] ) // 배열의 각 열을 검사해  current_user가  한 줄을 채웠는지 확인해 줍니다.
{

	int i2,m;
	char winner='U';
	
	for(i2=0; i2<length; i2++)
	{   
		for(m=0 ; m<length ; m++)   	// 한 열을 검사하다가  현재 순서가 아닌 사람의 돌( O 또는 X )이 나오면 그 열을 더이상 확인하지 않고 나갑니다.   
			if( board[m][i2] != current_user)	
				break;
		
		
		if( m == length )		// 위의 for문을 나갔을때  행(m)이  length 와 같다면 한 열이 모두 current_user의 돌이으므로  승자를 출력합니다. 
		{
			printf("winner = %c",current_user);         
					
			return TRUE;
		}
					
	}
	
	if( i2 == length)	// 모든 열을 검사했을때 if 문이 실행 됩니다. 이 경우는 한 열을 채운것이 없는 것이므로 FALSE를 반환합니다. 
		return FALSE;
		
}

int check_board_CL(char current_user, char board[100][100])	// 판의 왼쪽에서 시작하는 대각선이 채워졌는지 확인 합니다. 
{
	int i3,m;
	char winner='U';
	
	for(i3=0; i3<length; i3++)
		if( board[i3][i3] != current_user  )	// 대각선을 검사하다가 현재순서가 아닌 사람의 돌이 나오면 더 이상 확인 하지 않고 for문을 나갑니다. 
			break;
			
	if( i3 == length )		// for문을 나왔을때 대각선 끝까지 확인을 한 경우 이면( 대각선칸 모두가 O또는 X이면) 승자를 출력합니다. 
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}

int check_board_CR(char current_user, char board[100][100])	// 판의 오른쪽에서 시작하는 대각선이 채워졌는지 확인 합니다. 
{
	int i4;

	for(i4=0; i4<length; i4++)		
		if( board[i4][length- i4 - 1] != current_user )			// 대각선을 검사하다가 현재순서가 아닌 사람의 돌이 나오면 더 이상 확인 하지 않고 for문을 나갑니다. 
			break;

	
	if( i4 == length )				// for문을 나왔을때 대각선 끝까지 확인을 한 경우 이면( 대각선칸 모두가 O또는 X이면) 승자를 출력합니다. 
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}  


int main(int argc, char *argv[]) 
{ 
    char board[100][100]; 
    int quit;	// 종료할지를 받는 변수 
    int type; // 대결 종류를 받는 변수 
    int  count=0;
    
    init_board (board); // 배열안 모든 변수를 촉화 합니다. 
    
	printf("사람과 사람 대결 : 1을 입력하세요\n");
   	printf("컴퓨터와 대결 : 2를 입력하세요\n:");
   	scanf("%d", &type);
    
    printf("\n\n첫번째 사람은 X, 두번째 사람은 O입니다.\n\n");
    
    printf("상자의 크기를 입력하세요 :");
    scanf("%d",&length);

	print_board (board);  
	 
	switch(type)
	{
		
		case 1:		
		 	do {  
		      			   
			   quit = get_player_move(0, board);        
			   count++; 
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  ) //'X'돌을 가진 사람이 한줄을 채웠는지 확인합니다. 
			   		break;        		// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   
			   quit = get_player_move(1,board);        
			   count++;
			   
			   if( quit == TRUE ) break;  
			   
			   print_board (board);     
			   
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) //'O'돌을 가진 사람이 한줄을 채웠는지 확인합니다.
			   		break;				// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   	
				if(count == length*length)
				{
					printf("모든 턴이 종료되었습니다.\n");
			   		break;
				}
					
			} while(quit == FALSE );  //quit가 TRUE면 나가게 됩니다. 
		   
		   break;
		
		case 2:
			do {  
		      
			   
			   quit = get_player_move(0, board);        
			   count++;
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  )	//'X'돌을 가진 사람이 한줄을 채웠는지 확인합니다.
			   		break;        		// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   
			   quit = get_next_move(board);      // 랜덤으로 돌을 놓습니다.  
			   count++;
			   			   
			   print_board (board);     
			   
			   
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) 	//'컴퓨터가  한줄을 채웠는지 확인합니다.
			   		break;				// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다. 
			   		
			   if(count == length*length)
			   {
			   		printf("모든 턴이 종료되었습니다.\n");	
			   		break;	
			   }
			
			} while(quit == FALSE );  //quit가 TRUE면 나가게 됩니다. 
		   
		   break;
			
	 	default:
		 	printf(" 잘못입력하였습니다. 다시 시작하세요. ");  //1,2를 선택하지 않는 경우입니다. 
			break;  
	}
	
	return 0;
}






#include <stdio.h>
#include <stdlib.h>
#define TRUE 1	// TRUE면 나갑니다. 
#define FALSE 0 // FALSE면 계속됩니다. 

/*
p.414에 있는 Tic-Tac-Toe 게임을 수행할 수 있는 프로그램을 작성하시오.
예제에 있는 내용에서 다음의 내용이 추가되어야 합니다.

1. 게임이 종료(한명이라도 승리 했는지)하는 조건을 검사하는 함수 추가
2. 예제는 3 * 3게임만 할 수 있지만, 사용자가 원하면 5 * 5, 7 * 7 등의 게임을 추가(최대 99?)
3. 사람과 사람이 대결하는 것이 아니라 사람과 컴퓨터가 대결할 수 있도록 추가
(랜덤으로 놓기, 비어있는 위치 중 가장 앞 위치 놓기, 가장 유리한 곳 놓기 등) 
*/

int length; // n*n 에서 n의 값입니다. 

void print_board (char board[100][100] ) // 입력받은 크기로 tic tac toe 판을 출력합니다. 
{
   int row,colum;   // 순서대로 게임 판의 가로,세로 입니다.  

   for( row = 0 ; row < length ; row++)  
   {
      for( colum  = 0 ; colum  < length ; colum ++)
         printf("|%c",board[row][colum ]);
      
   		printf("|\n");
	}

	printf("\n\n"); 
	
   return;   
}

void init_board (char board[100][100])	//배열을 공백으로 초기화합니다. 
{
   int x,y;
   
   for( x=0 ; x<100 ; x++)
      for( y=0 ; y<100 ; y++)
         board[x][y] =' ';
      
   return;
}

int get_player_move(int player, char board[100][100])  // 놓고 싶은 위치에 자신의 돌을 두게 합니다. 
{    
	int x, y; 
	  
	while(1) 			// 입력받은 위치가 비어있는 위치를 확인합니다  . 
	{        
		printf("(x, y) 좌표(종료-1, -1): ");        
		scanf("%d %d", &x, &y); 
		       
		if( x == -1 && y == -1 ) 
			return  TRUE;
			        
		     
		if( (x>= 0 && x<length) && (y>=0 && y<length) ) //입력받은 크기(length)보다 큰수를 받지 않도록 합니다. 
		{
		
			if(board[x][y]== ' ') 
				break;  // 올바른 위치이면 반복 루프를 나갑니다.   
			else 
				printf("잘못된 위치입니다.\n");    
		}
		else
			printf("잘못된 위치입니다.\n");   
	
	}
	    
	
	if( player == 0 ) 
		board[x][y] = 'X';    
	else 
		board[x][y] = 'O';
    
	return FALSE; 
}

int get_next_move(char board[100][100])		// 컴퓨터와 하는 게임을 선택 했을떄,  비어있는 칸을 확인해서 무작위로  돌을 놓는 함수 입니다. 
{
	int x, y;
	
	
	while(1)// 비어있는경우, 돌을 놓습니다.  아니라면 다시 다른 위치의 돌ㄹ을 받도록 합니다. 
	{
	
		x = rand()%length;
		y = rand()%length;
			
		 
		if( board[x][y] == ' ') // 비어이이는 경우. 
		{ 
			board[x][y] = 'O';
			printf(" 컴퓨터 (%d,%d)\n",x,y);
				
			return FALSE;	// 종료하는 경우가 없어 항상 FALS 를 반환합니다. 
		}
	}
					
}


// check_board ~ 는 게임에서 승리한 사람이 있는지 확인 해주는 함수 입니다.
 
int check_board_H(char current_user, char board[100][100])  // 배열의 각 행을 검사해  current_user가  한줄을 채웠는지 확인해 줍니다. 
{    
	int i1,m;
	char winner='U';
	
    for(i1=0; i1<length; i1++)	
	{   								 
		for(m=0 ; m<length ; m++)		
			if( board[i1][m] != current_user)	// 한 행을 검사하다가  현재 순서가 아닌 사람의 돌( O 또는 X )이 나오면 그 행을 더이상 확인하지 않고 나갑니다.   
				break;
	
		if( m == length )			// 위의 for문을 나갔을때  열(m)이  length 와 같다면 한 행이 모두 current_user의 돌이으므로  승자를 출력합니다. 
			{
				printf("winner = %c",current_user);         
				
				return TRUE;  
			} 
	}
	
	if( i1 == length)		// 모든 행을 검사했을때 if 문이 실행 됩니다. 이 경우는 한 행을 채운것이 없는 것이므로 FALSE를 반환합니다. 
		return FALSE;		 
}


int check_board_V (char current_user,char board[100][100] ) // 배열의 각 열을 검사해  current_user가  한 줄을 채웠는지 확인해 줍니다.
{

	int i2,m;
	char winner='U';
	
	for(i2=0; i2<length; i2++)
	{   
		for(m=0 ; m<length ; m++)   	// 한 열을 검사하다가  현재 순서가 아닌 사람의 돌( O 또는 X )이 나오면 그 열을 더이상 확인하지 않고 나갑니다.   
			if( board[m][i2] != current_user)	
				break;
		
		
		if( m == length )		// 위의 for문을 나갔을때  행(m)이  length 와 같다면 한 열이 모두 current_user의 돌이으므로  승자를 출력합니다. 
		{
			printf("winner = %c",current_user);         
					
			return TRUE;
		}
					
	}
	
	if( i2 == length)	// 모든 열을 검사했을때 if 문이 실행 됩니다. 이 경우는 한 열을 채운것이 없는 것이므로 FALSE를 반환합니다. 
		return FALSE;
		
}

int check_board_CL(char current_user, char board[100][100])	// 판의 왼쪽에서 시작하는 대각선이 채워졌는지 확인 합니다. 
{
	int i3,m;
	char winner='U';
	
	for(i3=0; i3<length; i3++)
		if( board[i3][i3] != current_user  )	// 대각선을 검사하다가 현재순서가 아닌 사람의 돌이 나오면 더 이상 확인 하지 않고 for문을 나갑니다. 
			break;
			
	if( i3 == length )		// for문을 나왔을때 대각선 끝까지 확인을 한 경우 이면( 대각선칸 모두가 O또는 X이면) 승자를 출력합니다. 
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}

int check_board_CR(char current_user, char board[100][100])	// 판의 오른쪽에서 시작하는 대각선이 채워졌는지 확인 합니다. 
{
	int i4;

	for(i4=0; i4<length; i4++)		
		if( board[i4][length- i4 - 1] != current_user )			// 대각선을 검사하다가 현재순서가 아닌 사람의 돌이 나오면 더 이상 확인 하지 않고 for문을 나갑니다. 
			break;

	
	if( i4 == length )				// for문을 나왔을때 대각선 끝까지 확인을 한 경우 이면( 대각선칸 모두가 O또는 X이면) 승자를 출력합니다. 
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}  


int main(int argc, char *argv[]) 
{ 
    char board[100][100]; 
    int quit;	// 종료할지를 받는 변수 
    int type; // 대결 종류를 받는 변수 
    int  count=0;
    
    init_board (board); // 배열안 모든 변수를 촉화 합니다. 
    
	printf("사람과 사람 대결 : 1을 입력하세요\n");
   	printf("컴퓨터와 대결 : 2를 입력하세요\n:");
   	scanf("%d", &type);
    
    printf("\n\n첫번째 사람은 X, 두번째 사람은 O입니다.\n\n");
    
    printf("상자의 크기를 입력하세요 :");
    scanf("%d",&length);

	print_board (board);  
	 
	switch(type)
	{
		
		case 1:		
		 	do {  
		      			   
			   quit = get_player_move(0, board);        
			   count++; 
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  ) //'X'돌을 가진 사람이 한줄을 채웠는지 확인합니다. 
			   		break;        		// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   
			   quit = get_player_move(1,board);        
			   count++;
			   
			   if( quit == TRUE ) break;  
			   
			   print_board (board);     
			   
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) //'O'돌을 가진 사람이 한줄을 채웠는지 확인합니다.
			   		break;				// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   	
				if(count == length*length)
				{
					printf("모든 턴이 종료되었습니다.\n");
			   		break;
				}
					
			} while(quit == FALSE );  //quit가 TRUE면 나가게 됩니다. 
		   
		   break;
		
		case 2:
			do {  
		      
			   
			   quit = get_player_move(0, board);        
			   count++;
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  )	//'X'돌을 가진 사람이 한줄을 채웠는지 확인합니다.
			   		break;        		// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   
			   quit = get_next_move(board);      // 랜덤으로 돌을 놓습니다.  
			   count++;
			   			   
			   print_board (board);     
			   
			   
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) 	//'컴퓨터가  한줄을 채웠는지 확인합니다.
			   		break;				// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다. 
			   		
			   if(count == length*length)
			   {
			   		printf("무승부입니다.\n모든 턴이 종료되었습니다.\n");
			   		break;	
			   }
			
			} while(quit == FALSE );  //quit가 TRUE면 나가게 됩니다. 
		   
		   break;
			
	 	default:
		 	printf(" 잘못입력하였습니다. 1또는 2를 입력하세요. ");   //1,2를 선택하지 않는 경우입니다. 
			break;  
	}
	
	return 0;
}





#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#define TRUE 1	// TRUE면 나갑니다. 
#define FALSE 0 // FALSE면 계속됩니다. 

/*
p.414에 있는 Tic-Tac-Toe 게임을 수행할 수 있는 프로그램을 작성하시오.
예제에 있는 내용에서 다음의 내용이 추가되어야 합니다.

1. 게임이 종료(한명이라도 승리 했는지)하는 조건을 검사하는 함수 추가
2. 예제는 3 * 3게임만 할 수 있지만, 사용자가 원하면 5 * 5, 7 * 7 등의 게임을 추가(최대 99?)
3. 사람과 사람이 대결하는 것이 아니라 사람과 컴퓨터가 대결할 수 있도록 추가
(랜덤으로 놓기, 비어있는 위치 중 가장 앞 위치 놓기, 가장 유리한 곳 놓기 등) 
*/

int length; // n*n 에서 n의 값입니다. 
int count ; // 플레이 횟수. 

void print_board (char board[100][100] ) // 입력받은 크기로 tic tac toe 판을 출력합니다. 
{
   int row,colum;   // 순서대로 게임 판의 가로,세로 입니다.  

   for( row = 0 ; row < length ; row++)  
   {
      for( colum  = 0 ; colum  < length ; colum ++)
         printf("|%c",board[row][colum ]);
      
   		printf("|\n");
	}
	
	printf("\n\n"); 
	
   return;   
}

void init_board (char board[100][100])	//배열을 공백으로 초기화합니다. 
{
   int x,y;
   
   for( x=0 ; x<100 ; x++)
      for( y=0 ; y<100 ; y++)
         board[x][y] =' ';
      
   return;
}

int get_player_move(int player, char board[100][100])  // 놓고 싶은 위치에 자신의 돌을 두게 합니다. 
{    
	int x, y; 
	  
	while(1) 			// 입력받은 위치가 비어있는지  확인합니다  . 
	{        
		printf("[%d]\n (x, y) 좌표(종료-1, -1): ",count);        
		scanf("%d %d", &x, &y); 
		       
		if( x == -1 && y == -1 ) 
			return  TRUE;
			        
		     
		if( (x>= 0 && x<length) && (y>=0 && y<length) ) //입력받은 크기(length)보다 큰수를 받지 않도록 합니다. 
		{
		
			if(board[x][y]== ' ') 
				break;  // 올바른 위치이면 반복 루프를 나갑니다.   
			else 
				printf("잘못된 위치입니다.\n");    
		}
		else
			printf("잘못된 위치입니다.\n");   
	
	}
	    
	
	if( player == 0 ) 
		board[x][y] = 'X';    
	else 
		board[x][y] = 'O';
    
	return FALSE; 
}

int get_next_move(int copy_count,char board[100][100])		// 컴퓨터와 하는 게임을 선택 했을떄,  비어있는 칸을 확인해서 무작위로  돌을 놓는 함수 입니다. 
{
	int x, y;
	
	if(copy_count == length*length-1)
		printf("[%d]\n무승부입니다.\n모든 턴이 종료되었습니다.\n",count+1);
	
	
	while(1)// 비어있는경우, 돌을 놓습니다.  아니라면 다시 다른 위치의 돌ㄹ을 받도록 합니다. 
	{
	
		x = rand()%length;
		y = rand()%length;
			
		 
		if( board[x][y] == ' ') // 비어이이는 경우. 
		{ 
			board[x][y] = 'O';
			printf("[%d]\n컴퓨터 (%d,%d)\n",count,x,y);
				
			return FALSE;	// 종료하는 경우가 없어 항상 FALS 를 반환합니다. 
		}
	}
					
}


// check_board ~ 는 게임에서 승리한 사람이 있는지 확인 해주는 함수 입니다.
 
int check_board_H(char current_user, char board[100][100])  // 배열의 각 행을 검사해  current_user가  한줄을 채웠는지 확인해 줍니다. 
{    
	int i1,m;
	char winner='U';
	
    for(i1=0; i1<length; i1++)	
	{   								 
		for(m=0 ; m<length ; m++)		
			if( board[i1][m] != current_user)	// 한 행을 검사하다가  현재 순서가 아닌 사람의 돌( O 또는 X )이 나오면 그 행을 더이상 확인하지 않고 나갑니다.   
				break;
	
		if( m == length )			// 위의 for문을 나갔을때  열(m)이  length 와 같다면 한 행이 모두 current_user의 돌이으므로  승자를 출력합니다. 
			{
				printf("winner = %c",current_user);         
				
				return TRUE;  
			} 
	}
	
	if( i1 == length)		// 모든 행을 검사했을때 if 문이 실행 됩니다. 이 경우는 한 행을 채운것이 없는 것이므로 FALSE를 반환합니다. 
		return FALSE;		 
}


int check_board_V (char current_user,char board[100][100] ) // 배열의 각 열을 검사해  current_user가  한 줄을 채웠는지 확인해 줍니다.
{

	int i2,m;
	char winner='U';
	
	for(i2=0; i2<length; i2++)
	{   
		for(m=0 ; m<length ; m++)   	// 한 열을 검사하다가  현재 순서가 아닌 사람의 돌( O 또는 X )이 나오면 그 열을 더이상 확인하지 않고 나갑니다.   
			if( board[m][i2] != current_user)	
				break;
		
		
		if( m == length )		// 위의 for문을 나갔을때  행(m)이  length 와 같다면 한 열이 모두 current_user의 돌이으므로  승자를 출력합니다. 
		{
			printf("winner = %c",current_user);         
					
			return TRUE;
		}
					
	}
	
	if( i2 == length)	// 모든 열을 검사했을때 if 문이 실행 됩니다. 이 경우는 한 열을 채운것이 없는 것이므로 FALSE를 반환합니다. 
		return FALSE;
		
}

int check_board_CL(char current_user, char board[100][100])	// 판의 왼쪽에서 시작하는 대각선이 채워졌는지 확인 합니다. 
{
	int i3,m;
	char winner='U';
	
	for(i3=0; i3<length; i3++)
		if( board[i3][i3] != current_user  )	// 대각선을 검사하다가 현재순서가 아닌 사람의 돌이 나오면 더 이상 확인 하지 않고 for문을 나갑니다. 
			break;
			
	if( i3 == length )		// for문을 나왔을때 대각선 끝까지 확인을 한 경우 이면( 대각선칸 모두가 O또는 X이면) 승자를 출력합니다. 
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}

int check_board_CR(char current_user, char board[100][100])	// 판의 오른쪽에서 시작하는 대각선이 채워졌는지 확인 합니다. 
{
	int i4;

	for(i4=0; i4<length; i4++)		
		if( board[i4][length- i4 - 1] != current_user )			// 대각선을 검사하다가 현재순서가 아닌 사람의 돌이 나오면 더 이상 확인 하지 않고 for문을 나갑니다. 
			break;

	
	if( i4 == length )				// for문을 나왔을때 대각선 끝까지 확인을 한 경우 이면( 대각선칸 모두가 O또는 X이면) 승자를 출력합니다. 
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}  


int main(int argc, char *argv[]) 
{ 
    char board[100][100]; 
    int quit;	// 종료할지를 받는 변수 
    int type; // 대결 종류를 받는 변수 
    int  count=0;
    
    init_board (board); // 배열안 모든 변수를 촉화 합니다. 
    
	printf("사람과 사람 대결 : 1을 입력하세요\n");
   	printf("컴퓨터와 대결 : 2를 입력하세요\n:");
   	scanf("%d", &type);
    
    printf("\n\n첫번째 사람은 X, 두번째 사람은 O입니다.\n\n");
    
    printf("상자의 크기를 입력하세요 :");
    scanf("%d",&length);

	print_board (board);  
	 
	switch(type)
	{
		
		case 1:		
		 	do {  
		      			   
			   quit = get_player_move(0, board);        
			   count++; 
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  ) //'X'돌을 가진 사람이 한줄을 채웠는지 확인합니다. 
			   		break;        		// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   
			   quit = get_player_move(1,board);        
			   
			   if( quit == TRUE ) break;  
			   
			   print_board (board);   
			   
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) //'O'돌을 가진 사람이 한줄을 채웠는지 확인합니다.
			   		break;				// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   	
				
					
			} while(quit == FALSE );  //quit가 TRUE면 나가게 됩니다. 
		   
		   break;
		
		case 2:
			do {  
		      
			   
			   quit = get_player_move(0, board);        
			   count++;
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  )	//'X'돌을 가진 사람이 한줄을 채웠는지 확인합니다.
			   		break;        		// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   
			   quit = get_next_move(board);      // 랜덤으로 돌을 놓습니다.  
			   			   
			   print_board (board);     
			   
			  
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) 	//'컴퓨터가  한줄을 채웠는지 확인합니다.
			   		break;				// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다. 
			   		
			  
			
			} while(quit == FALSE );  //quit가 TRUE면 나가게 됩니다. 
		   
		   break;
			
	 	default:
		 	printf(" 잘못입력하였습니다. 1또는 2를 입력하세요. ");  //1,2를 선택하지 않는 경우입니다. 
			break;  
	}
	
	return 0;
}




딱울언ㄹㄴ아럼너끝났다~~~~~~~~~~~~~~~~~


#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#define TRUE 1	// TRUE면 나갑니다. 
#define FALSE 0 // FALSE면 계속됩니다. 

/*
p.414에 있는 Tic-Tac-Toe 게임을 수행할 수 있는 프로그램을 작성하시오.
예제에 있는 내용에서 다음의 내용이 추가되어야 합니다.

1. 게임이 종료(한명이라도 승리 했는지)하는 조건을 검사하는 함수 추가
2. 예제는 3 * 3게임만 할 수 있지만, 사용자가 원하면 5 * 5, 7 * 7 등의 게임을 추가(최대 99?)
3. 사람과 사람이 대결하는 것이 아니라 사람과 컴퓨터가 대결할 수 있도록 추가
(랜덤으로 놓기, 비어있는 위치 중 가장 앞 위치 놓기, 가장 유리한 곳 놓기 등) 
*/

int length; // n*n 에서 n의 값입니다. 
int count ; // 플레이 횟수. 

void print_board (char board[100][100] ) // 입력받은 크기로 tic tac toe 판을 출력합니다. 
{
   int row,colum;   // 순서대로 게임 판의 가로,세로 입니다.  

   for( row = 0 ; row < length ; row++)  
   {
      for( colum  = 0 ; colum  < length ; colum ++)
         printf("|%c",board[row][colum ]);
      
   		printf("|\n");
	}
	
	printf("\n\n"); 
	
   return;   
}

void init_board (char board[100][100])	//배열을 공백으로 초기화합니다. 
{
   int x,y;
   
   for( x=0 ; x<100 ; x++)
      for( y=0 ; y<100 ; y++)
         board[x][y] =' ';
      
   return;
}

int get_player_move(int player, char board[100][100])  // 놓고 싶은 위치에 자신의 돌을 두게 합니다. 
{    
	int x, y; 

	  
	while(1) 			// 입력받은 위치가 비어있는지  확인합니다  . 
	{        
		printf("[%d]\n (x, y) 좌표(종료-1, -1): ",count);        
		scanf("%d %d", &x, &y); 
		       
		if( x == -1 && y == -1 ) 
			return  TRUE;
			        
		     
		if( (x>= 0 && x<length) && (y>=0 && y<length) ) //입력받은 크기(length)보다 큰수를 받지 않도록 합니다. 
		{
		
			if(board[x][y]== ' ') 
				break;  // 올바른 위치이면 반복 루프를 나갑니다.   
			else 
				printf("잘못된 위치입니다.\n");    
		}
		else
			printf("잘못된 위치입니다.\n");   
	
	}
	    
	if( player == 0 ) 
		board[x][y] = 'X';    
	else 
		board[x][y] = 'O';
		
	if(count == length*length)
		printf("[%d]\n무승부입니다.\n모든 턴이 종료되었습니다.\n",count);
    
	return FALSE; 
}

int get_next_move(char board[100][100])		// 컴퓨터와 하는 게임을 선택 했을떄,  비어있는 칸을 확인해서 무작위로  돌을 놓는 함수 입니다. 
{
	int x, y;
	
	
	while(1)// 비어있는경우, 돌을 놓습니다.  아니라면 다시 다른 위치의 돌ㄹ을 받도록 합니다. 
	{
	
		x = rand()%length;
		y = rand()%length;
			
		 
		if( board[x][y] == ' ') // 비어이이는 경우. 
		{ 
			board[x][y] = 'O';
			printf("[%d]\n컴퓨터 (%d,%d)\n",count,x,y);
				
			return FALSE;	// 종료하는 경우가 없어 항상 FALS 를 반환합니다. 
		}
	}
					
}


// check_board ~ 는 게임에서 승리한 사람이 있는지 확인 해주는 함수 입니다.
 
int check_board_H(char current_user, char board[100][100])  // 배열의 각 행을 검사해  current_user가  한줄을 채웠는지 확인해 줍니다. 
{    
	int i1,m;
	char winner='U';
	
    for(i1=0; i1<length; i1++)	
	{   								 
		for(m=0 ; m<length ; m++)		
			if( board[i1][m] != current_user)	// 한 행을 검사하다가  현재 순서가 아닌 사람의 돌( O 또는 X )이 나오면 그 행을 더이상 확인하지 않고 나갑니다.   
				break;
	
		if( m == length )			// 위의 for문을 나갔을때  열(m)이  length 와 같다면 한 행이 모두 current_user의 돌이으므로  승자를 출력합니다. 
			{
				printf("winner = %c",current_user);         
				
				return TRUE;  
			} 
	}
	
	if( i1 == length)		// 모든 행을 검사했을때 if 문이 실행 됩니다. 이 경우는 한 행을 채운것이 없는 것이므로 FALSE를 반환합니다. 
		return FALSE;		 
}


int check_board_V (char current_user,char board[100][100] ) // 배열의 각 열을 검사해  current_user가  한 줄을 채웠는지 확인해 줍니다.
{

	int i2,m;
	char winner='U';
	
	for(i2=0; i2<length; i2++)
	{   
		for(m=0 ; m<length ; m++)   	// 한 열을 검사하다가  현재 순서가 아닌 사람의 돌( O 또는 X )이 나오면 그 열을 더이상 확인하지 않고 나갑니다.   
			if( board[m][i2] != current_user)	
				break;
		
		
		if( m == length )		// 위의 for문을 나갔을때  행(m)이  length 와 같다면 한 열이 모두 current_user의 돌이으므로  승자를 출력합니다. 
		{
			printf("winner = %c",current_user);         
					
			return TRUE;
		}
					
	}
	
	if( i2 == length)	// 모든 열을 검사했을때 if 문이 실행 됩니다. 이 경우는 한 열을 채운것이 없는 것이므로 FALSE를 반환합니다. 
		return FALSE;
		
}

int check_board_CL(char current_user, char board[100][100])	// 판의 왼쪽에서 시작하는 대각선이 채워졌는지 확인 합니다. 
{
	int i3,m;
	char winner='U';
	
	for(i3=0; i3<length; i3++)
		if( board[i3][i3] != current_user  )	// 대각선을 검사하다가 현재순서가 아닌 사람의 돌이 나오면 더 이상 확인 하지 않고 for문을 나갑니다. 
			break;
			
	if( i3 == length )		// for문을 나왔을때 대각선 끝까지 확인을 한 경우 이면( 대각선칸 모두가 O또는 X이면) 승자를 출력합니다. 
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}

int check_board_CR(char current_user, char board[100][100])	// 판의 오른쪽에서 시작하는 대각선이 채워졌는지 확인 합니다. 
{
	int i4;

	for(i4=0; i4<length; i4++)		
		if( board[i4][length- i4 - 1] != current_user )			// 대각선을 검사하다가 현재순서가 아닌 사람의 돌이 나오면 더 이상 확인 하지 않고 for문을 나갑니다. 
			break;

	
	if( i4 == length )				// for문을 나왔을때 대각선 끝까지 확인을 한 경우 이면( 대각선칸 모두가 O또는 X이면) 승자를 출력합니다. 
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}  


int main(int argc, char *argv[]) 
{ 
    char board[100][100]; 
    int quit;	// 종료할지를 받는 변수 
    int type; // 대결 종류를 받는 변수 
    
    init_board (board); // 배열안 모든 변수를 촉화 합니다. 
    
	printf("사람과 사람 대결 : 1을 입력하세요\n");
   	printf("컴퓨터와 대결 : 2를 입력하세요\n:");
   	scanf("%d", &type);
    
    printf("\n\n첫번째 사람은 X, 두번째 사람은 O입니다.\n\n");
    
    printf("상자의 크기를 입력하세요 :");
    scanf("%d",&length);

	print_board (board);  
	 
	switch(type)
	{
		
		case 1:		
		 	do {  
		       
				count++;		   
			   quit = get_player_move(0, board);        
			   
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  ) //'X'돌을 가진 사람이 한줄을 채웠는지 확인합니다. 
			   		break;        		// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   
			   count++;
			    quit = get_player_move(1,board);        
			   
			   if( quit == TRUE ) break;  
			   
			   print_board (board);   
			   
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) //'O'돌을 가진 사람이 한줄을 채웠는지 확인합니다.
			   		break;				// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   	
				
					
			} while(quit == FALSE );  //quit가 TRUE면 나가게 됩니다. 
		   
		   break;
		
		case 2:
			do {  
		      
		       ++count;
			   quit = get_player_move(0, board);        
			  
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  )	//'X'돌을 가진 사람이 한줄을 채웠는지 확인합니다.
			   		break;        		// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   
			   ++count;
			   quit = get_next_move(board);      // 랜덤으로 돌을 놓습니다.  
			   			   
			   print_board (board);     
			   
			  
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) 	//'컴퓨터가  한줄을 채웠는지 확인합니다.
			   		break;				// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다. 
			   		
			  
			
			} while(quit == FALSE );  //quit가 TRUE면 나가게 됩니다. 
		   
		   break;
			
	 	default:
		 	printf(" 잘못입력하였습니다. 1또는 2를 입력하세요. ");  //1,2를 선택하지 않는 경우입니다. 
			break;  
	}
	
	return 0;
}








2@@@@@아싸@~~~


#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#define TRUE 1	// TRUE면 나갑니다. 
#define FALSE 0 // FALSE면 계속됩니다. 

/*
p.414에 있는 Tic-Tac-Toe 게임을 수행할 수 있는 프로그램을 작성하시오.
예제에 있는 내용에서 다음의 내용이 추가되어야 합니다.

1. 게임이 종료(한명이라도 승리 했는지)하는 조건을 검사하는 함수 추가
2. 예제는 3 * 3게임만 할 수 있지만, 사용자가 원하면 5 * 5, 7 * 7 등의 게임을 추가(최대 99?)
3. 사람과 사람이 대결하는 것이 아니라 사람과 컴퓨터가 대결할 수 있도록 추가
(랜덤으로 놓기, 비어있는 위치 중 가장 앞 위치 놓기, 가장 유리한 곳 놓기 등) 
*/

int length; // n*n 에서 n의 값입니다. 
int count ; // 플레이 횟수. 

void print_board (char board[100][100] ) // 입력받은 크기로 tic tac toe 판을 출력합니다. 
{
   int row ,colum;   // 순서대로 게임 판의 가로,세로 입니다.  

   for( row = 0 ; row < length ; row++)  
   {
      for( colum  = 0 ; colum  < length ; colum ++)
         printf("|%c",board[row][colum ]);
      
   		printf("|\n");
	}
	
	printf("\n\n"); 
	
   return;   
}

void init_board (char board[100][100])	//배열을 공백으로 초기화합니다. 
{
   int x,y;
   
   for( x=0 ; x<100 ; x++)
      for( y=0 ; y<100 ; y++)
         board[x][y] =' ';
      
   return;
}

int get_player_move(int player, char board[100][100])  // 놓고 싶은 위치에 자신의 돌을 두게 합니다. 
{    
	int x, y; 

	  
	while(1) 			// 입력받은 위치가 비어있는지  확인합니다  . 
	{        
		printf("[%d]\n (x, y) 좌표(종료-1, -1): ",count);        
		scanf("%d %d", &x, &y); 
		       
		if( x == -1 && y == -1 ) 
			return  TRUE;
			        
		     
		if( (x>= 0 && x<length) && (y>=0 && y<length) ) //입력받은 크기(length)보다 큰수를 받지 않도록 합니다. 
		{
		
			if(board[x][y]== ' ') 
				break;  // 올바른 위치이면 반복 루프를 나갑니다.   
			else 
				printf("잘못된 위치입니다.\n");    
		}
		else
			printf("잘못된 위치입니다.\n");   
	
	}
	    
	if( player == 0 ) 
		board[x][y] = 'X';    
	else 
		board[x][y] = 'O';
	
	return FALSE; 
}

int get_next_move(char board[100][100])		// 컴퓨터와 하는 게임을 선택 했을떄,  비어있는 칸을 확인해서 무작위로  돌을 놓는 함수 입니다. 
{
	int x, y;
	
	
	while(1)// 비어있는경우, 돌을 놓습니다.  아니라면 다시 다른 위치의 돌ㄹ을 받도록 합니다. 
	{
	
		x = rand()%length;
		y = rand()%length;
			
		 
		if( board[x][y] == ' ') // 비어이이는 경우. 
		{ 
			board[x][y] = 'O';
			printf("[%d]\n컴퓨터 (%d,%d)\n",count,x,y);
			
			return FALSE;	// 종료하는 경우가 없어 항상 FALS 를 반환합니다. 
		}
	
	}
					
}


// check_board ~ 는 게임에서 승리한 사람이 있는지 확인 해주는 함수 입니다.
 
int check_board_H(char current_user, char board[100][100])  // 배열의 각 행을 검사해  current_user가  한줄을 채웠는지 확인해 줍니다. 
{    
	int i1,m;
	char winner='U';
	
    for(i1=0; i1<length; i1++)	
	{   								 
		for(m=0 ; m<length ; m++)		
			if( board[i1][m] != current_user)	// 한 행을 검사하다가  현재 순서가 아닌 사람의 돌( O 또는 X )이 나오면 그 행을 더이상 확인하지 않고 나갑니다.   
				break;
	
		if( m == length )			// 위의 for문을 나갔을때  열(m)이  length 와 같다면 한 행이 모두 current_user의 돌이으므로  승자를 출력합니다. 
			{
				printf("winner = %c",current_user);         
				
				return TRUE;  
			} 
	}
	
	if( i1 == length)		// 모든 행을 검사했을때 if 문이 실행 됩니다. 이 경우는 한 행을 채운것이 없는 것이므로 FALSE를 반환합니다. 
		return FALSE;		 
}


int check_board_V (char current_user,char board[100][100] ) // 배열의 각 열을 검사해  current_user가  한 줄을 채웠는지 확인해 줍니다.
{

	int i2,m;
	char winner='U';
	
	for(i2=0; i2<length; i2++)
	{   
		for(m=0 ; m<length ; m++)   	// 한 열을 검사하다가  현재 순서가 아닌 사람의 돌( O 또는 X )이 나오면 그 열을 더이상 확인하지 않고 나갑니다.   
			if( board[m][i2] != current_user)	
				break;
		
		
		if( m == length )		// 위의 for문을 나갔을때  행(m)이  length 와 같다면 한 열이 모두 current_user의 돌이으므로  승자를 출력합니다. 
		{
			printf("winner = %c",current_user);         
					
			return TRUE;
		}
					
	}
	
	if( i2 == length)	// 모든 열을 검사했을때 if 문이 실행 됩니다. 이 경우는 한 열을 채운것이 없는 것이므로 FALSE를 반환합니다. 
		return FALSE;
		
}

int check_board_CL(char current_user, char board[100][100])	// 판의 왼쪽에서 시작하는 대각선이 채워졌는지 확인 합니다. 
{
	int i3,m;
	char winner='U';
	
	for(i3=0; i3<length; i3++)
		if( board[i3][i3] != current_user  )	// 대각선을 검사하다가 현재순서가 아닌 사람의 돌이 나오면 더 이상 확인 하지 않고 for문을 나갑니다. 
			break;
			
	if( i3 == length )		// for문을 나왔을때 대각선 끝까지 확인을 한 경우 이면( 대각선칸 모두가 O또는 X이면) 승자를 출력합니다. 
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}

int check_board_CR(char current_user, char board[100][100])	// 판의 오른쪽에서 시작하는 대각선이 채워졌는지 확인 합니다. 
{
	int i4;

	for(i4=0; i4<length; i4++)		
		if( board[i4][length- i4 - 1] != current_user )			// 대각선을 검사하다가 현재순서가 아닌 사람의 돌이 나오면 더 이상 확인 하지 않고 for문을 나갑니다. 
			break;

	
	if( i4 == length )				// for문을 나왔을때 대각선 끝까지 확인을 한 경우 이면( 대각선칸 모두가 O또는 X이면) 승자를 출력합니다. 
	{
		printf("winner = %c",current_user);         
					
		return TRUE;
	} 
	else
		return FALSE;
		
}  




int main(int argc, char *argv[]) 
{ 
    char board[100][100]; 
    int quit;	// 종료할지를 받는 변수 
    int type; // 대결 종류를 받는 변수 
    
    init_board (board); // 배열안 모든 변수를 촉화 합니다. 
    
	printf("사람과 사람 대결 : 1을 입력하세요\n");
   	printf("컴퓨터와 대결 : 2를 입력하세요\n:");
   	scanf("%d", &type);
    
    printf("\n\n첫번째 사람은 X, 두번째 사람은 O입니다.\n\n");
    
    printf("상자의 크기를 입력하세요 :");
    scanf("%d",&length);

	print_board (board);  
	 
	switch(type)
	{
		
		case 1:		
		 	do {  
		       
				count++;		   
			   quit = get_player_move(0, board);        
			   
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  ) //'X'돌을 가진 사람이 한줄을 채웠는지 확인합니다. 
			   		break;        		// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   
			   if(count == length*length)
				{
					printf("[%d]\n무승부입니다.\n모든 턴이 종료되었습니다.\n",count);
				    	
				   	return  TRUE;
				}
				
			   count++;
			    quit = get_player_move(1,board);        
			   
			   if( quit == TRUE ) break;  
			   
			   print_board (board);   
			   
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) //'O'돌을 가진 사람이 한줄을 채웠는지 확인합니다.
			   		break;				// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   	
				
				if(count == length*length)
				{
					printf("[%d]\n무승부입니다.\n모든 턴이 종료되었습니다.\n",count);
				    	
				   	return  TRUE;
				}	
								
			} while(quit == FALSE );  //quit가 TRUE면 나가게 됩니다. 
		   
		   break;
		
		case 2:
			do {  
		      
		       ++count;
			   quit = get_player_move(0, board);        
			  
			   
			   if( quit == TRUE) break;         
			   
			   print_board (board);  
			   
			   if( check_board_H('X',board) || check_board_V('X',board) || check_board_CL('X',board) || check_board_CR('X',board)  )	//'X'돌을 가진 사람이 한줄을 채웠는지 확인합니다.
			   		break;        		// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다.  
			   
			   
			   if(count == length*length)
				{
					printf("[%d]\n무승부입니다.\n모든 턴이 종료되었습니다.\n",count);
				    	
				   	return  TRUE;
				}
				
				
				++count;
			   quit = get_next_move(board);      // 랜덤으로 돌을 놓습니다.  
			   			   
			   print_board (board);     
			   
			  
			   if( check_board_H('O',board) || check_board_V('O',board) || check_board_CL('O',board) || check_board_CR('O',board)) 	//'컴퓨터가  한줄을 채웠는지 확인합니다.
			   		break;				// check_board ~ 함수중 하나라도 TRUE를 반환하면 do while 을 나가게되어 종료됩니다. 
			   		
			  	if(count == length*length)
				{
					printf("[%d]\n무승부입니다.\n모든 턴이 종료되었습니다.\n",count);
					    	
					return  TRUE;
				}
			
			} while(quit == FALSE );  //quit가 TRUE면 나가게 됩니다. 
		   
		   break;
			
	 	default:
		 	printf(" 잘못입력하였습니다. 1또는 2를 입력하세요. ");  //1,2를 선택하지 않는 경우입니다. 
			break;  
	}
	
	return 0;
}